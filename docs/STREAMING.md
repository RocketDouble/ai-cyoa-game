# Text Streaming Feature

## Overview
The CYOA game now supports real-time text streaming, similar to SillyTavern, where story text appears character-by-character as it's generated by the AI.

## How It Works

### 1. **AIService Streaming**
- Added `chatCompletionStream()` method that uses Server-Sent Events (SSE)
- Processes streaming responses chunk by chunk
- Calls a callback function with each text chunk received

### 2. **StoryService Streaming**
- Added `generateInitialStoryStream()` for new stories
- Added `continueStoryStream()` for story continuations
- Both methods accept an `onChunk` callback that receives text as it streams

### 3. **UI Components**
- **StoryDisplay**: Shows streaming text with a blinking cursor indicator
- **GameManager**: Manages streaming state and accumulates text chunks
- Smooth transition from streaming to final text display

## User Experience

### Enabling/Disabling Streaming:
1. Click the "Sampler" button in the game interface
2. Toggle "Enable Text Streaming" on or off
3. Setting is saved automatically
4. Takes effect on the next story generation

### When Streaming is Enabled:
**Starting a New Story:**
1. User clicks "Start New Adventure"
2. Text begins appearing character-by-character
3. A blinking cursor shows text is still streaming
4. Once complete, choices appear below

**Making a Choice:**
1. User selects a choice
2. New story text streams in real-time
3. Cursor indicator shows streaming progress
4. Choices appear after streaming completes

### When Streaming is Disabled:
- Shows loading spinner while generating
- Text appears all at once when complete
- Traditional loading experience

## Technical Details

### Streaming Flow:
```
User Action → StoryService.xxxStream() → AIService.chatCompletionStream()
                                              ↓
                                         SSE Response
                                              ↓
                                         onChunk callback
                                              ↓
                                    GameManager updates state
                                              ↓
                                    StoryDisplay renders text
```

### State Management:
- `enableStreaming`: User preference stored in sampler settings (default: true)
- `streamingText`: Accumulates text chunks during streaming
- `isStreaming`: Boolean flag indicating active streaming
- `isLoading`: Set to false during streaming, true when streaming is disabled
- Text is displayed from `streamingText` while streaming
- Switches to `currentStory.text` when complete

### Key Implementation Details:
- When streaming starts, `isLoading` is set to `false` to prevent the loading spinner
- The `isStreaming` flag controls whether to show streaming text or final text
- StoryDisplay checks `isStreaming` before showing the loading state
- Choices and images are hidden during streaming for a cleaner experience

## Benefits

1. **Better UX**: More engaging and interactive feel
2. **Perceived Performance**: Users see progress immediately
3. **SillyTavern-like**: Familiar experience for users of chat interfaces
4. **Real-time Feedback**: Know the AI is working without waiting
5. **User Choice**: Toggle on/off based on preference

## Configuration

### Sampler Settings:
The streaming toggle is located in the Sampler Settings modal:
- **Location**: Click "Sampler" button in game interface
- **Setting**: "Enable Text Streaming" toggle
- **Default**: Enabled (true)
- **Persistence**: Saved with other sampler settings

### For Developers:
The setting is stored in `SamplerSettings.enableStreaming`:
```typescript
interface SamplerSettings {
  temperature: number;
  minP: number;
  repetitionPenalty: number;
  enableStreaming?: boolean; // Default: true
}
```

## Fallback Behavior

The implementation automatically switches between streaming and non-streaming:
- **Streaming enabled**: Uses `generateInitialStoryStream()` / `continueStoryStream()`
- **Streaming disabled**: Uses `generateInitialStory()` / `continueStory()`

Both methods are maintained for compatibility and user preference.
